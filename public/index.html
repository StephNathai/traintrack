<!DOCTYPE html>
<html>
  <head>
    <title>trainTrack</title>
    <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
    <meta charset="utf-8">
    <script src="/jquery-2.1.4.js"></script>
    <link rel="stylesheet" type="text/css" href="style.css">
  </head>
  <body>
    <div id="floating-panel1">
      <button id="clear" onclick="clearPolylines()">Map</button>
    </div>
    <div id="one-all">
      <button id="oneAll" onclick="oneAll()">One</button>
    </div>
    <div id="one-north">
      <button id="oneNorth" onclick="oneNorth()">OneNorth</button>
    </div>
    <div id="one-south">
      <button id="oneSouth" onclick="oneSouth()">OneSouth</button>
    </div>
    <div id="two-all">
      <button id="twoAll" onclick="twoAll()">Two</button>
    </div>
    <div id="two-north">
      <button id="twoNorth" onclick="twoNorth()">TwoNorth</button>
    </div>
    <div id="two-south">
      <button id="twoSouth" onclick="twoSouth()">TwoSouth</button>
    </div>


    <div id="map"></div>
    <!-- <script src="/map.jsx" type="text/jsx"></script>
    <script src="http://fb.me/react-0.12.2.js"></script>
    <script src="http://fb.me/JSXTransformer-0.12.2.js"></script>
    <script type="text/jsx">
      React.render(<MapApp />, document.getElementById('map'));
    </script> -->
    <script src="/socket.io/socket.io.js"></script>
    <!-- <script src="shapes1.js"></script> -->
    <script>
    //Client side code
    var socket = io(); //create an io connection
    var map;
    var route1;
    var route2;
    var oneArray = [];
    var oneNorthArray = [];
    var oneSouthArray = [];
    var twoArray = [];
    var twoNorthArray = [];
    var twoSouthArray = [];
    var markers = [];
    var transitLayer;
    var trainOnePath
    var trainTwoPath;

      //grabs parsed MTA data and prints it
      socket.on('parsed_data', function(lineOne, stops1, lineTwo, stops2){
        console.log('lineOne', lineOne, lineOne.length)
        for(var i=0; i<lineOne.length; i++){
          stops1.forEach(function(e,k){
          if(lineOne[i] == e.id && lineOne[i][3] === "N"){
            oneNorthArray.push(e.data)
          } else if (lineOne[i] == e.id && lineOne[i][3] === "S") {
            oneSouthArray.push(e.data)
          }
        })
       }

       for(var i=0; i<lineOne.length; i++){
         stops1.forEach(function(e,k){
         if(lineOne[i] == e.id){
           oneArray.push(e.data)
         }
       })
      }

       console.log('oneArray', oneArray, oneArray.length)
       console.log('oneNorthArray', oneNorthArray, oneNorthArray.length)
       console.log('oneSouthArray', oneSouthArray, oneSouthArray.length)


       oneAll = function() {
        clearMarkers();
        if (trainTwoPath) {
          trainTwoPath.setMap(null)
          drawOneLine()
          for (var i = 0; i < oneArray.length; i++) {
            addMarkerWithTimeout(oneArray[i], i * 200);
          }
        } else {
        drawOneLine()
        for (var i = 0; i < oneArray.length; i++) {
          addMarkerWithTimeout(oneArray[i], i * 200);
        }
       }
     }

       oneNorth = function() {
        clearMarkers();
        if (trainTwoPath) {
          trainTwoPath.setMap(null)
          drawOneLine()
          for (var i = 0; i < oneNorthArray.length; i++) {
            addMarkerWithTimeout(oneNorthArray[i], i * 200);
          }
        } else {
        drawOneLine()
        for (var i = 0; i < oneNorthArray.length; i++) {
          addMarkerWithTimeout(oneNorthArray[i], i * 200);
        }
       }
     }

       oneSouth = function() {
        clearMarkers();
        if (trainTwoPath) {
          trainTwoPath.setMap(null)
          drawOneLine()
          for (var i = 0; i < oneSouthArray.length; i++) {
            addMarkerWithTimeout(oneSouthArray[i], i * 200);
          }
        } else {
        drawOneLine()
        for (var i = 0; i < oneSouthArray.length; i++) {
          addMarkerWithTimeout(oneSouthArray[i], i * 200);
        }
       }
     }

       console.log('lineTwo', lineTwo, lineTwo.length)
       for(var i=0; i<lineTwo.length; i++){
         stops2.forEach(function(e,k){
         if(lineTwo[i] == e.id && lineTwo[i][3] === "N"){
           twoNorthArray.push(e.data)
         } else if (lineTwo[i] == e.id && lineTwo[i][3] === "S") {
           twoSouthArray.push(e.data)
         }
       })
      }

      for(var i=0; i<lineTwo.length; i++){
        stops2.forEach(function(e,k){
        if(lineTwo[i] == e.id){
          twoArray.push(e.data)
        }
      })
     }

      console.log('twoArray', twoArray, twoArray.length)
      console.log('twoNorthArray', twoNorthArray, twoNorthArray.length)
      console.log('twoSouthArray', twoSouthArray, twoSouthArray.length)


      twoAll = function() {
       clearMarkers();
       if (trainOnePath) {
         trainOnePath.setMap(null)
         drawTwoLine();
         for (var i = 0; i < twoArray.length; i++) {
           addMarkerWithTimeout(twoArray[i], i * 200);
         }
       } else {
       drawTwoLine();
       for (var i = 0; i < twoArray.length; i++) {
         addMarkerWithTimeout(twoArray[i], i * 200);
       }
      }
      }

      twoNorth = function() {
       clearMarkers();
       if (trainOnePath) {
         trainOnePath.setMap(null)
         drawTwoLine();
         for (var i = 0; i < twoNorthArray.length; i++) {
           addMarkerWithTimeout(twoNorthArray[i], i * 200);
         }
       } else {
       drawTwoLine();
       for (var i = 0; i < twoNorthArray.length; i++) {
         addMarkerWithTimeout(twoNorthArray[i], i * 200);
       }
      }
    }

      twoSouth = function() {
       clearMarkers();
       if (trainOnePath) {
         trainOnePath.setMap(null)
         drawTwoLine();
         for (var i = 0; i < twoSouthArray.length; i++) {
           addMarkerWithTimeout(twoSouthArray[i], i * 200);
         }
       } else {
       drawTwoLine();
       for (var i = 0; i < twoSouthArray.length; i++) {
         addMarkerWithTimeout(twoSouthArray[i], i * 200);
       }
      }
    }


       function addMarkerWithTimeout(position, timeout) {
        window.setTimeout(function() {
          markers.push(new google.maps.Marker({
            position: position,
            map: map,
            animation: google.maps.Animation.DROP
          }));
        }, timeout);
       }

       clearMarkers = function() {
        //transitLayerMap();
        for (var i = 0; i < markers.length; i++) {
          markers[i].setMap(null);
        }
        markers = [];
      }


      }); //io

      socket.on('shapes1', function(shapes1) {
        //console.log(shapes1)
        drawOneLine = function() {
        route1 = shapes1
        var train1Coordinates = [];

        shapes1.forEach(function(e,k){
          train1Coordinates.push(e)
        });

        trainOnePath = new google.maps.Polyline({
          path: train1Coordinates,
          geodesic: true,
          strokeColor: '#FF0000',
          strokeOpacity: 1.0,
          strokeWeight: 3
        });

        trainOnePath.setMap(map);
        }

      }); //socket shapes 1 close

      socket.on('shapes2', function(shapes2) {
        //console.log(shapes1)
        drawTwoLine = function() {
        route2 = shapes2
        var train2Coordinates = [];

        shapes2.forEach(function(e,k){
          train2Coordinates.push(e)
        });

        trainTwoPath = new google.maps.Polyline({
          path: train2Coordinates,
          geodesic: true,
          strokeColor: '#0000FF',
          strokeOpacity: 1.0,
          strokeWeight: 1
        });

        trainTwoPath.setMap(map);
        }



      }); //socket shapes 2close

      clearPolylines = function() {
        if (trainOnePath) {
          trainOnePath.setMap(null)
          clearMarkers();
        } else if (trainTwoPath) {
          trainTwoPath.setMap(null)
          clearMarkers();
        } else if (trainTwoPath && trainOnePath){
          clearMarkers();
        } else {
          clearMarkers();
        }
      }
        // combined geo-location and layer-transit to compile Google map
        // https://developers.google.com/maps/documentation/javascript/examples/map-geolocation
        // https://developers.google.com/maps/documentation/javascript/examples/layer-transit
        function initMap() {

          map = new google.maps.Map(document.getElementById('map'), {
            center: {lat: 40.7127, lng: -74.0059}, //this is set to NYC lat and long
            zoom: 15
          });

        //this adds transit layer
        // transitLayerMap = function() {
        //   transitLayer = new google.maps.TransitLayer();
        //   transitLayer.setMap(map);
        // }

        // this grabs the users location if they allow it
          var infoWindow = new google.maps.InfoWindow({map: map});

          if (navigator.geolocation) {
            navigator.geolocation.getCurrentPosition(function(position) {
              var pos = {
                lat: position.coords.latitude,
                lng: position.coords.longitude
              };

              infoWindow.setPosition(pos);
              infoWindow.setContent('Location found.');
              map.setCenter(pos);

            }, function() {
              handleLocationError(true, infoWindow, map.getCenter());
            });
          } else {
            // Browser doesn't support Geolocation
            handleLocationError(false, infoWindow, map.getCenter());
          }
        }

        function handleLocationError(browserHasGeolocation, infoWindow, pos) {
          infoWindow.setPosition(pos);
          infoWindow.setContent(browserHasGeolocation ?
                                'Error: The Geolocation service failed.' :
                                'Error: Your browser doesn\'t support geolocation.');
        }

    </script>
    <script src="https://maps.googleapis.com/maps/api/js?&callback=initMap&signed_in=true" async defer></script>
  </body>
</html>
